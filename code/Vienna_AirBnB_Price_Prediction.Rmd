---
title: "Vienna AirBnB Price Prediction"
author: "John Joyce"
date: "7/20/2021"
output: 
  html_document:
    theme: "cosmo"
    toc: true
    toc_depth: 2
    toc_float: true
    code_folding: hide
---

```{r document setup}

# show code but not console output in report
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

```

# Introduction  

My task is to help a company offering small and mid-size apartments find the right price for their new AirBnb units in Vienna. I do this by building a model for predicting Airbnb prices with publicly available data from [InsideAirbnb](http://insideairbnb.com/get-the-data.html). We can run the model on the client's apartments to figure out what an appropriate price is for each unit.  
  
The Vienna AirBnb data has approximately 10.000 observations after cleaning and preparation. The **mean price** is about €68 and the **average number of reviews** is 33. However, 17% of the apartments in the data have 0 reviews, just like the client's properties.

```{r load data and packages}

# set data directories (RMDs always set their own dir as the working dir)
raw_data_dir <- "../data/raw/"
clean_data_dir <- "../data/clean/"

# load libraries
library(knitr)
library(kableExtra)
library(tidyverse)
library(caret)
library(ranger)

# load data
df <- read_csv(paste0(raw_data_dir,'listings.csv.gz'))

```

# Cleaning and Filtering  

In the cleaning and filtering stage, I need to accomplish two goals:  
  
* adjusting the sample to be more representative of the properties of the properties we want to model  
* preparing the data for machine learning  

## Adjusting the Sample

The data contains 61 different property types. But our client only has one property type: **apartment**. We'll trim the sample down to apartment-style properties.  

``` {r property types table}

# 'Entire apartment' + 'Private room in apartment' are 87% of obs, 
# there are 59 other types, and each is <= 2.3% of total obs

df %>% 
  group_by(property_type) %>% 
  summarize(count = n()) %>% 
  arrange(desc(count)) %>% 
  kable() %>% 
  kable_material(c("striped", "hover")) %>% 
  scroll_box(height = "350px")

```
  
  
Fortunately, 87% of the data are **Entire apartment** or **private room in apartment**, plus there are a few more **serviced apartments**. We still have a large sample size. I keep any property which is an apartment of some kind, and I filter out anything that is not.  

```{r filter property types}

# identify apartments with string detection on property_type column and recode any other value to 'Other'
df <-
  df %>% 
  mutate(property_type = ifelse(str_detect(property_type, 'apartment|Apartment'), 'Apartment', 'Other'))

# keep only apartments
df <- 
  df %>%
  filter(property_type == 'Apartment')

```  

A quick look at the **room_type** column reveal something odd. If our data has been filtered to apartments, why do we have the **Hotel room** room type? 

```{r examine room type}

# look at the room_type column... why do we have hotel rooms?
df %>% 
  group_by(room_type) %>% 
  summarize(count = n()) %>% 
  arrange(desc(count)) %>% 
  kable() %>% 
  kable_material(c("striped", "hover"))

```
  
I clean this up by dropping **Hotel room** observations and renaming **Entire home/apt** to **Entire apartment** to be more accurate.  

```{r drop hotel rooms}

# discard hotel rooms with a negated filter
df <-
  df %>% 
  filter(!room_type == 'Hotel room')

# rename 'Entire home/apt' to 'Entire apartment'
df <-
  df %>% 
  mutate(room_type = ifelse(room_type == 'Entire home/apt', 'Entire apartment', room_type))


```


The client's apartments accommodate **two to six guests**. Therefore, I filter out any apartments which are not in this range. 

```{r filter accommodates}

# filter to include apartments which meet our criteria: accomodates 2-6 people
df <- 
  df %>% 
  filter(accommodates %in% 2:6)

```

The client's apartments all have at least one bathroom. We can filter out the small number of apartments which have zero bathrooms or just a half-bath (dude, who is renting these...) and also do some basic cleaning on the **bathrooms_text** column while we are at it. Currently, this column is an ugly string with values such as *1 bath* or *2.5 shared baths*. I convert these values to a numeric stored in **bathrooms** and add a flag for apartments which have shared bath facilities.

```{r filter bathrooms}

# extract number of bathrooms from string column, store in numeric column
df <-
  df %>% 
  mutate(bathrooms = str_extract(bathrooms_text, '\\d\\.*\\d*')) 

# add flag for shared bathrooms
df <- 
  df %>% 
  mutate(shared_bathroom = ifelse(str_detect(bathrooms_text, 'shared'), 1, 0))

# keep only apartments with one more more bathrooms
df <- 
  df %>% filter(bathrooms >= 1)

```

I also filter out apartments which have **extreme values for price**. The client does not have super expensive luxury apartments, and having luxury apartments in the sample for the pricing model is not helpful. These values (whether they are real values for luxury apartments or data entry mistakes) are going to hurt the accuracy of the model. I set the cutoff at €600 per night - which comes out to €100 - €300 per person for apartments which accommodate 2 - 6 guests.     

```{r drop extreme values for price}

# strip dollar signs from values in price column by taking substring starting at second position ("$100" --> "100")
df <-
  df %>% 
  mutate(price = str_sub(price, start = 2))

# convert to numeric
df$price <- as.numeric(df$price)

# check for NAs, it turns out there are 19. small number, let's drop them
# sum(is.na(df$price))

# drop price NAs
df <-
  df %>% 
  filter(!is.na(price))

# visualize price histogram with annotated cutoff point
df %>% 
    ggplot(aes(x = price)) + 
    geom_histogram() +
    annotate("segment", x = 600, xend = 600, y = 0, yend = 2000, size = 1.5, color = "red") +
    annotate("text", x = 600, y = 2200, label = "Luxury Price Cutoff", size = 6, color = "red")
  

# we should drop extreme values to improve our predictions
# but also because luxury apartments are not relevant comparisons for our business case
df <-
  df %>% 
  filter(price <= 600)


```

## Prep data for machine learning

The data needs to be in a clean format before it can be passed to a model. The key tasks are:  
  
* dealing with NAs  
* feature engineering with clean variable names/types  
* dropping unneeded variables  

Some important columns have NAs. When these occur in the **price** column, they must be dropped. When these occur in the columns which are used as predictive features, they can be dropped or imputed if the number is relatively small. However, there is one difficult case: the **bedrooms** column has more than 1000 NAs in the original data. This is about 10% of the data after filtering. I take a conservative approach here: I won't impute or drop these values, because there could be a systemic reason that the information is missing (ex. hosts are hiding the information because it's unfavorable). I leave these observations in the data, and I set **NA** as a **factor level** when doing prediction.  

I drop unneeded variables to make the data easier to work with. Using domain knowledge or common sense, I drop anything I am confident will not help to predict **price**. For the client's case, I also drop **review scores** columns. Typically, reviews  would be highly useful features for modeling price. But in the client's case, we are trying to predict the appropriate price for properties which don't have any reviews because they are new to the market. We can't confidently impute values for the missing review scores: we don't know how much guests will enjoy these particular properties, how accurate they will find the listing, how well the client will perform the host duties overall, etc. I decide to keep the **number_of_reviews** variable because we do have this information (it's zero).  

```{r select useful columns}

# drop a bunch of variables we won't use to make wrangling amenities a little easier
# do this by selecting only the variables we are interested in
df <- 
  df %>% 
  select(id, 
         name, 
         neighbourhood_cleansed, 
         room_type, 
         accommodates,
         bathrooms,
         bedrooms,
         beds,
         amenities,
         price,
         instant_bookable,
         number_of_reviews,
         shared_bathroom)

```
  
I do a small amount of feature engineering. Every row in the **amenities** column contains a messy string which no machine learning tool will be able to use as a predictive feature.  

![](../docs/images/raw_amenities_screenshot.jpg)

I make binary variables for every unique value in **amenities**, which describes all the small features that are included with an Airbnb (appliances, sound systems, patios, etc.) To get the most out of this information, I consolidate amenities which are extremely similar, such as refrigerators of different brands and different varieties of stoves. Many variables are renamed to replace spaces with underscores. 

```{r binary variables for amenities}

# first create unique list of all amenities in the data
# the regex pattern captures amenities of any number of words
amenities_unique <-
  unique(
    unlist(
      df$amenities %>% str_extract_all('(?<=")(\\w+\\s*)*(?=")')
    )
  )

# then iterate over the list and create a new column for each unique amenity and fill values with this logic:
# in the new column, if the amenity is detected as a string in the original "amenities" at this row, set value to 1
# else set value to 0
for (i in amenities_unique){
  df <- 
    df %>% 
    mutate(!! i := ifelse(str_detect(amenities, !! i), 1, 0))
}

# mutate columns to aggregate amenities - refrigerators, ovens, stoves of different types
# this checks for any type of refrigerator, oven or stove unit, etc. and sets value to 1 if present
# example: Refrigerator = 1 if it is a refrigerator, Siemens refrigerator, Gorenje refrigerator, Miele refrigerator, etc...
df <-
  df %>% 
  mutate(Refrigerator = ifelse(str_detect(amenities, "Refrigerator|refrigerator"), 1, 0)) %>% 
  mutate(Oven = ifelse(str_detect(amenities, "Oven|oven"), 1, 0)) %>% 
  mutate(Stove = ifelse(str_detect(amenities, "Stove|stove"), 1, 0)) %>% 
  mutate(`Body Soap` = ifelse(str_detect(amenities, "Body soap|body soap|Shower gel"), 1, 0)) %>% 
  mutate(Shampoo = ifelse(str_detect(amenities, "Shampoo|shampoo"), 1, 0)) %>% 
  mutate(Conditioner = ifelse(str_detect(amenities, "Conditioner|conditioner"), 1, 0)) %>% 
  mutate(Netflix = ifelse(str_detect(amenities, "Netflix|netflix"), 1, 0)) %>% 
  mutate(`Amazon Prime Video` = ifelse(str_detect(amenities, "Amazon Prime Video"), 1, 0)) %>% 
  mutate(`Air conditioning` = ifelse(str_detect(amenities, "Air conditioning|air conditioning|Window AC"), 1, 0)) %>% 
  mutate(TV = ifelse(str_detect(amenities, "TV"), 1, 0)) %>% 
  mutate(`Hot tub` = ifelse(str_detect(amenities, "Hot tub|hot tub"), 1, 0)) %>% 
  mutate(`Sound system` = ifelse(str_detect(amenities, "Sound system|sound system"), 1, 0)) %>% 
  mutate(`Free parking` = ifelse(str_detect(amenities, "Parking|parking") & str_detect(amenities, "Free|free"), 1, 0)) %>% 
  mutate(`Paid parking` = ifelse(str_detect(amenities, "Parking|parking") & str_detect(amenities, "Paid|paid"), 1, 0))


# vector of vars to drop: all the hyper-specific appliances which have been aggregated into more general amenities
vars_to_drop <- c('Cable TV', 
                  'Shower gel', 
                  'Zanussi oven', 
                  'Zanussi electric stove', 
                  'Zanussi refrigerator',
                  'Window AC unit',
                  'Electric stove',
                  'HDTV with Netflix',
                  'Central air conditioning',
                  'Nivea body soap',
                  'Bodyshop body soap',
                  'Stainless steel oven',
                  'TV with Netflix',
                  'HDTV',
                  'Induction stove',
                  'SIEMENS oven',
                  'AEG refrigerator',
                  'Duschgel body soap',
                  'Private hot tub',
                  'Gorenje induction stove',
                  'Gorenje refrigerator',
                  'Portable air conditioning',
                  'Cerankochfeld electric stove',
                  'Siemens oven',
                  'Siemens refrigerator',
                  'Oranier induction stove',
                  'Rituals body soap',
                  'Rituals shampoo',
                  'variouse body soap',
                  'various conditioner',
                  'Bauknecht refrigerator',
                  'TV with Chromecast',
                  'Miele refrigerator',
                  'Paid parking off premises',                           
                  'Free parking on premises',                                                     
                  'Paid parking on premises',                           
                  'TV with standard cable',                              
                  'Paid parking garage off premises',                   
                  'Paid street parking off premises',                    
                  'HDTV with standard cable',                           
                  'Grundig Ovation sound system with aux',               
                  'Stainless steel electric stove',                     
                  'Paid parking lot on premises',                        
                  'Sound system with aux',                              
                  'Free parking garage on premises',                                            
                  'Paid parking garage on premises',                     
                  'Sound system with Bluetooth and aux',                
                  'Samsung TV with integrated sound system sound system',
                  'Philip Starck Parrot Bluetooth sound system',        
                  'SAVON PUR VEGETAL ROSE DE MAI body soap',             
                  'Stainless steel gas stove',                          
                  'Gorenje stainless steel oven',                        
                  'Paid parking lot off premises',                      
                  'LG sound system with Bluetooth and aux',              
                  'Yamaha Bluetooth sound system',                      
                  'Gorenje stainless steel electric stove',              
                  'HDTV with Amazon Prime Video',                       
                  'Stainless steel induction stove',                     
                  'Miele stainless steel oven',                         
                  'Miele stainless steel induction stove',
                  'Free street parking',        
                  'Bluetooth sound system',                
                  'amenities') # we don't need the original amenities column anymore

# drop the vars using the vector 
df <- 
    df %>% 
    select(-all_of(vars_to_drop))

# rename columns: replace all spaces with underscores
names(df) <- str_replace_all(names(df), '\\s', '_')

```
  

Now that I'm done adjusting the sample and manipulating the data, I take one last check for NAs in the features.  

```{r last check for NAs}

# count NAs for all columns except "id" and "name", which are just labels, not predictive features
na_info <- 
  df %>% 
  select(-c('id', 'name')) %>% 
  summarise_all(funs(sum(is.na(.))))

# show NAs
na_info[,colSums(na_info>0)>0]  %>% 
  kable() %>% 
  kable_material(c("striped", "hover"))


```  

There are two columns with NAs: **beds** and **bedrooms**. The number of NAs in **beds** is small - I can just drop them without any significant impact on our sample. But the number of NAs in **bedrooms** is a bigger portion of our sample. I don't think there is an easy way to impute this. You can't just assume that there is one bedroom for every two beds. There could be a systemic reason for missing data here, which would make simply imputing median values dangerous and misleading. (For example, hosts might tend to omit information about the number of bedrooms when the number is small...) I want to take a conservative approach: leave the observations in the data and set NA as factor level when doing prediction.  

```{r drop remaining NAs in beds}

# there are 70 NAs in beds - this is small number in our 10k obs, so we can afford to drop these
df <-
  df %>% 
  drop_na(beds)

```  

I save the clean data to a separate CSV file.  

```{r write clean data to CSV}

# write out a clean CSV
write_csv(df, paste0(clean_data_dir,'airbnb_vienna_midsize_clean.csv'))

```
